"""Regression tests for *smart prediction* on the snake-game examples.

Each test compares a **naïve sequential** predictor against a second,
alignment-aware predictor (selectable via the ``--predictor`` command-line
option, default: :class:`LineDiffPredictor`).  The
ground-truth document is the *baseline* ``snake_game.py`` whereas the
*prediction* is one of the three modified versions located in
``joev/data``.

The expectations are:

1. The advanced predictor must achieve a strictly **higher** composite score
   than the naïve baseline (it should re-anchor after the local differences).
2. The advanced predictor's score must be *positive* to rule out pathological
   behaviour where it blindly predicts too much and accumulates penalties.

When the tests are invoked with ``pytest -s`` the helper prints a coloured
diff-like visualisation where correctly predicted tokens appear **blue** and
tokens that had to be generated by the model show up **red**.  This mirrors
the diagnostic output used in ``test_smart_prediction.py`` so that developers
can eyeball the quality of the different algorithms.
"""

from __future__ import annotations

import pathlib
import pytest

from joev.src.smart_prediction.algorithms.naive_sequential import (
    NaiveSequentialPredictor,
)
from joev.src.smart_prediction.algorithms.line_diff import LineDiffPredictor
from joev.src.smart_prediction.algorithms.greedy_suffix import GreedySuffixPredictor
from joev.src.smart_prediction.algorithms.myers_streaming import MyersStreamingPredictor
from joev.src.smart_prediction.algorithms.myers_lines import MyersLinePredictor
from joev.src.smart_prediction.simulator import simulate
from joev.src.smart_prediction.tokenizer import BasicTokenizer

# ---------------------------------------------------------------------------
# Pytest fixtures – expose command-line options to individual tests
# ---------------------------------------------------------------------------


@pytest.fixture(scope="session")
def lookahead(request) -> int:
    """Amount of look-ahead tokens used in the simulation (CLI: --look-ahead)."""

    # Prefer the dashed option; fall back to underscore name if pytest normalises.
    for opt in ("--look-ahead", "look_ahead"):
        try:
            return int(request.config.getoption(opt))
        except ValueError:
            continue
    return 32


@pytest.fixture(scope="session")
def advanced_predictor_cls(request):
    """Return the predictor class selected via ``--predictor``.

    The option is *case-insensitive* and may be one of

    * ``line_diff`` – :class:`LineDiffPredictor` (default)
    * ``greedy_suffix`` – :class:`GreedySuffixPredictor`
    * ``naive_sequential`` – :class:`NaiveSequentialPredictor` (mainly for debugging).
    * ``myers`` – :class:`MyersStreamingPredictor` (token-level diff alignment).
    * ``myers_lines`` – :class:`MyersLinePredictor` (line-level Myers alignment).
    """

    for opt in ("--predictor", "predictor"):
        try:
            name = request.config.getoption(opt)
            break
        except ValueError:
            continue
    else:
        name = "line_diff"
    name = name.lower()
    mapping = {
        "line_diff": LineDiffPredictor,
        "greedy_suffix": GreedySuffixPredictor,
        "naive_sequential": NaiveSequentialPredictor,
        "myers": MyersStreamingPredictor,
        "myers_lines": MyersLinePredictor,
    }

    if name not in mapping:
        raise pytest.UsageError(
            f"--predictor must be one of {', '.join(mapping)}, got '{name}'."
        )

    return mapping[name]


# ---------------------------------------------------------------------------
# Helper – coloured diagnostics identical to the one in the original test file
# ---------------------------------------------------------------------------


def _print_coloured_alignment(result, ground_truth_text, tokenizer):  # pragma: no cover
    """Show predicted tokens in *blue* and model tokens in *red* on stdout."""

    BLUE = "\033[94m"
    RED = "\033[91m"
    RESET = "\033[0m"

    ground_ids = tokenizer.encode(ground_truth_text)
    coloured_parts: list[str] = []
    for tok_id, was_predicted in zip(ground_ids, result.predicted_mask):
        txt = tokenizer.decode([tok_id])
        if txt == "\n":
            coloured_parts.append("\n")
            continue

        colour = BLUE if was_predicted else RED
        marker = "[P]" if was_predicted else "[M]"
        coloured_parts.append(f"{colour}{marker}{txt}{RESET}")

    # Join tokens, taking newlines into account so that the output resembles
    # a conventional *diff*.
    lines: list[str] = []
    buffer: list[str] = []
    for part in coloured_parts:
        if part == "\n":
            lines.append(" ".join(buffer))
            buffer = []
        else:
            buffer.append(part)
    if buffer:
        lines.append(" ".join(buffer))

    print("\n[DEBUG] Predicted tokens in blue, model tokens in red:\n")
    print("\n".join(lines))


# ---------------------------------------------------------------------------
# Test data – baselines & variants
# ---------------------------------------------------------------------------


DATA_DIR = pathlib.Path(__file__).resolve().parent.parent / "data"


BASE_FILE = DATA_DIR / "snake_game.py"
VARIANT_FILES = [
    DATA_DIR / "snake_game_01-fast-big.py",
    DATA_DIR / "snake_game_02-score.py",
    DATA_DIR / "snake_game_03-multiplayer.py",
]


def _load(path: pathlib.Path) -> str:
    return path.read_text(encoding="utf-8")


@pytest.mark.parametrize("variant_path", VARIANT_FILES, ids=[p.stem for p in VARIANT_FILES])
def test_snake_game_variants_outperform_naive(
    variant_path: pathlib.Path,
    lookahead: int,
    advanced_predictor_cls,
):
    """Ensure *LineDiff* predictor beats the naïve baseline on each variant."""

    predicted = _load(BASE_FILE)       # predictor believes *original* code will be produced
    ground_truth = _load(variant_path) # actual model output is the *modified* variant

    lookahead = 32  # tokens – sufficiently large for these examples


    # --- Naïve sequential predictor --------------------------------------
    res_naive = simulate(
        NaiveSequentialPredictor,
        predicted_text=predicted,
        ground_truth_text=ground_truth,
        lookahead=lookahead,
    )

    # --- Advanced predictor (selected via CLI) ---------------------------
    res_diff = simulate(
        advanced_predictor_cls,
        predicted_text=predicted,
        ground_truth_text=ground_truth,
        lookahead=lookahead,
    )

    # Human-readable coloured diff (only visible with `-s`).  We show the *better*
    # predictor to avoid flooding the output.
    _print_coloured_alignment(res_diff, ground_truth, BasicTokenizer())  # pragma: no cover

    # The alignment-aware predictor must do strictly better than naïve.
    assert res_diff.score > res_naive.score
    # Sanity: diff predictor should obtain a *positive* score on these inputs.
    assert res_diff.score > 0
